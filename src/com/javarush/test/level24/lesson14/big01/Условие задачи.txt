Задание 20
Наслаждаемся игрой


Задание 19
Осталось совсем чуть-чуть

Реализовать метод checkBricksBump
В этом методе надо проверить - не столкнулся ли шарик с каким-нибудь из "кирпичей"
Для проверки столкновения используй метод isIntersec
Если шарик все-таки попал в кирпич, то
а) шарик отлетает в случайном направлении (0..360 градусов)
double angel = Math.random() * 360;
ball.setDirection(angel);
б) кирпич умирает - надо удалить его из списка всех кирпичей

Реализовать метод checkStandBump
В этом методе надо проверить - не ударился ли шарик о подставку
Для проверки столкновения используй метод isIntersec
Если шарик все-таки ударился о подставку, то:
шарик отлетает в случайным направлении строго вверх (80..100 градусов)
double angel = 80 + Math.random()*20;
ball.setDirection(angel);

Реализовать метод checkEndGame
Если координата y шарика больше чем высота поля игры (height), значит шарик улетел вниз за границу экрана
В этом случае надо переменную isGameOver установить в true


Задание 18
Теперь вернемся к классу Arcanoid
Реализуй методы:
а) move()
В этом методе нужно двигать все движимые объекты (stand, ball)
б) draw(Canvas canvas)
В этом методе надо вызвать метод draw всех существующих объектов, которые его имеют.


Задание 17
Но и это еще не все
Еще нужны методы:
а) move  - см. move в BaseObject
Движение доски осуществляется горизонтально, поэтому мы меняем только координату х.
Подумай, как координата х зависит от направления (direction) и скорости (speed). Реализуй зависимость.
б) draw  - см. draw в BaseObject
Его кодом я займусь сам.
в) moveLeft() - задает постоянное движение "подставки" влево
Просто присвой правильное значение переменной direction и все.
г) moveRight() - задает постоянное движение "подставки" вправо
Просто присвой правильное значение переменной direction и все.


Задание 16
И наконец "подставка"!
Ей понадобятся такие переменные
а) speed (скорость шарика) типа double
б) direction (направление движения по оси x: 1 - вправо, -1 - влево) типа double
в) создай для них геттеры


А еще с тебя конструктор, примерно вот такой:
public Stand(double x, double y)
{
    super(x,y,3);
    speed = 1;
    direction = 0;
}


Задание 15
Не поверишь, но и это еще не все.

Во-первых нужен метод setDirection
Который не только устанавливает значение переменной direction,
но и вычисляет новые значения переменных x & y
Код должен выглядеть примерно так:
this.direction = direction;
double angel = Math.toRadians(direction);
dx = Math.cos(angel) * speed;
dy = -Math.sin(angel) * speed;

Во-вторых шарик может удариться о стенку.
При этом он должен от нее отскочить.
Для этого нам понадобится еще один метод:
public void checkRebound(int minx, int maxx, int miny, int maxy)
Создай его, кодом я займусь сам



Задание 14
Чего-то не хватает:

Во-первых надо переопределить метод move(), который наследуется от BaseObject
а) объявить такой же метод как и в BaseObject, только без ключевого слова abstract
б) написать его реализацию
x должен увеличиваться на dx каждый ход
y должен увеличиваться на dy каждый ход
если шарик "заморожен", то x и y меняться не должны

Во-вторых надо переопределить метод draw(Canvas canvas)
а) объявить такой же метод как и в BaseObject, только без ключевого слова abstract
б) написать его реализацию. Выглядеть она должна примерно так:
canvas.setPoint(x, y, 'O');

В третьих надо реализовать метод start()
Именно его вызов "размораживает" шарик.
Что для этого надо сделать - это ты уже сам реши.


Задание 13
Класс Ball уже посложнее - шарик же двигается.
Нам понадобятся переменные
а) speed (скорость шарика) типа double
б) direction (направление движения в градусах: от 0 до 360) типа double
в) dx (расстояние по x, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double.
г) dy (расстояние по y, которое проходит шарик за один шаг. вычисляется на основе speed и direction) типа double.
д) isFrozen ("истина" если шарик "заморожен" - не двигается) типа boolean
е) добавь геттеры для всех переменных этого класса

А еще сделай-ка конструктор:
а) в конструктор передаются x,y, speed, direction
б) радиус (для родительского класса) всегда равен 1
в) не забудь установить isFrozen в true - в начале игры шарик никуда не летит.


Задание 12
Теперь напишем класс Brick
Во-первых займемся конструктором и в нем точно зададим радиус всех "кирпичей".
Путь он выглядит так:
public Brick(double x, double y)
{
        super(x,y,3);
}

Еще нам нужно переопределить два метода move() и draw(Canvas canvas)
Метод move() не делает ничего (не содержит кода), т.к. кирпич никуда не двигается.

Напиши еще метод draw(Canvas canvas).
Его кодом я займусь сам.



Задание 11
Еще Canvas понадобится два метода, напиши их.
а) метод clear()
Этот метод будет очищать матрицу, чтобы на ней снова можно было рисовать.
Например заменить все символы матрицы на пробелы.

б) метод print()
Этот метод отрисовывает матрицу на экран.
Тут уже ты должен сам разобраться: вывести набор символов не так уж и сложно.
Не забудь добавить пару пустых строк в конце, чтобы матрицы выведенные в разное время не слипались.



Задание 10
Что мы будем делать с Canvas?
Мы будем рисовать на нем (в его матрице).
Поэтому нам понадобятся два метода
public void setPoint(double x, double y, char c)
public void drawMatrix(double x, double y, int[][] matrix, char c)

Первый метод - setPoint будет "ставить точку в координатах x,y цветом c".
В методе надо:
а) округлить x и y до целых чисел
б) занести в matrix[y][x] значение с
в) ничего не делать, если x<0 или y<0 или y>matrix.length или x>matrix[0].length

Второй метод - drawMatrix копирует переданную ему картинку (матрицу) в матрицу Canvas.
И не просто копирует, а начиная с координат x, y
В методе надо:
а) с помощью двух вложенных циклов пройтись по всем ячейкам переданной картинки
б) если значение ячейки matrix[i][j] не равно 0, то покрасить в матрице объекта Canvas точку (x+j, y+i) в цвет c:
 setPoint(x+j, y+i, c)



Задание 9
Теперь займемся классом Canvas.
Он у нас будет содержать матрицу(двумерный массив), куда мы будем "рисовать".
У матрицы есть ширина и высота.
А еще будем в ней хранить не числа (int), а символы (char).
Надо:
а) Добавить в класс две переменные width и height
б) Добавить в класс переменную matrix (char[][])
в) Добавить конструктор с width и height
г) Добавь геттеры для всех переменных класса
Я тут немного изменил класс BaseObject. Пройдись по классам наследникам.



Задание 8
Но и это еще не все.
Классу BaseObject нужны еще методы.
Пока это будут пустые методы draw() и move().
Классы-наследники должны будут переопределить их у себя и реализовать необходимую функциональность.
Объяви эти методы, но сделай их абстрактными.
Также сделай абстрактным сам класс BaseObject.

А еще нам нужно будет определять попал шарик в кирпич или в подставку.
Это будем делать так:
В этом же классе, создадим специальный метод: public boolean isIntersec(BaseObject o)
Он будет определять - "пересеклись" объекты или нет. Если пересеклись - возвращать true, если нет - false.

Т.к. объекты мы условно считаем кругами, то предлагаю такую формулу взаимодействия
Если центр круга одного объекта попал в круг другого, то будем считать, что они столкнулись.
Или еще проще:
дистанция_между_объектами < max (радиус_первого_объекта, радиус_второго_объекта)



Задание 7
Теперь перейдем к классу BaseObject.
Я хочу сделать несколько предложений.

Во-первых для простоты считать все объекты у нас будут круглыми.
Нет, отрисовывать их мы будем фигурными, как и раньше.
А вот при расчетах из взаимодействия исходить из того, что они круглые.
Так - гораздо проще.

Во-вторых. Пусть координаты объектов и радиус будут вещественными числами.
Это придаст плавность движениям и точность всем вычислениям.
А при отрисовке мы будем их округлять

Надо:
а) Добавь в класс BaseObject переменные x (double), y (double), radius (double)
б) Добавить геттеры и сеттеры
в) Добавь конструктор BaseObject(double x, double y, double radius)
г) Надо пройтись по все классам-наследникам и поправить у них конструкторы
Если вы пользуйтесь Intellij IDEA - Alt+Insert вам в помощь



Задание 6
У нас будут "кирпичи", "шарик" и "подставка" и у них будет много общего.
Они будут перемещаться по полю и отрисовываться.
Значит у них у всех будут координаты и размер.
А еще методы move() - для перемещения и draw() для отрисовки.

Есть интересное предложение: давай введем один базовый класс для все объектов.
Пусть это будет класс BaseObject.
А классы Ball, Stand, Brick от него наследуются.
Создай класс BaseObject и добавь его родителем к классам  Ball, Stand, Brick

Еще нам понадобится класс Canvas
Он будет ответственным за "отрисовку" объектов.
С помощью его они будут отрисовывать себя.
Вернее даже на нем, но детали я сообщу позднее.
Создай и этот класс.



Задание 5
Чего еще не хватает классу Arcanoid?
Ну во-первых ему нужен метод run(), в котором будет описана основная логика программы
Еще нужен метод move() - который будет двигать на один шаг все объекты требующие движения.
Создай методы run() и move().

Еще нам понадобится статическая переменная game типа Arcanoid, которая будет хранить ссылку
на созданный экземпляр класса Arcanoid.
Выглядеть это должно примерно так:
public static Arcanoid game;



Задание 4
Также классу Arcanoid нужно будет хранить ссылку на шарик (Ball) и "подставку" Stand.
И список "кирпичей"
Надо:
а) создать в классе Arcanoid две переменных ball типа Ball и stand типа Stand
б) добавить переменную bricks типа ArrayList<Brick>
в) добавь для них геттеры и сеттеры



Задание 3
Главному классу (Arcanoid) нужно будет хранить информацию о размерах поля, где будут происходить все действия.
Поэтому:
а) добавь ему две переменных width (ширина) типа int и height(высота) типа int
б) добавь их в конструктор класса
г) сделай для них геттеры и сеттеры



Задание 2
Добавь в класс Arcanoid метод main.



Задание 1
Давай сегодня напишем игру Арканоид.
В оригинале это выглядит примерно так http://www.youtube.com/watch?v=Th-Z6QQ5AOQ
Для начала мы напишем упрощенную версию этой игры.
У нас будут кубики, шарик и летающая "подставка", которая не дает шарику упасть.

Поэтому нам понадобятся классы:
а) Arcanoid - класс в котором происходят основные действия
б) Ball - шарик
в) Brick - "кирпичи", которые мы сбиваем шариком
г) Stand - летающая подставка

Создай их.
Задание 16.

	Осталось дописать реализацию загрузчика уровней.
16.1.	Открой файл levels.txt и внимательно изучи структуру файла. Символ ‘X’ –
означает стену, ‘*’ - ящик, ‘.’ – дом, ‘&’ – ящик который стоит в доме, а ‘@’ - игрока.
Всего в файле 60 уровней.
16.2.	Реализуй метод GameObjects getLevel(int level). Он должен:
16.2.1.	Вычитывать из файла данные уровня level. Уровни должны повторяться
циклически, если пользователь прошел все 60 уровней и попал на 61 уровень, то
ему нужно вернуть 1, вместо 62 уровня вернуть 2 и т.д.
16.2.2.	Создать все игровые объекты, описанные в указанном уровне. Координаты
каждого игрового объекта должны быть рассчитаны согласно следующей логике:
16.2.2.1.	Самый верхний левый объект (если такой есть) должен иметь
координаты x = x0 = FIELD_SELL_SIZE / 2 и y = y0 = FIELD_SELL_SIZE / 2.
16.2.2.2.	Объект, который находится на одну позицию правее от него должен
иметь координаты x = x0 + FIELD_SELL_SIZE и y = y0.
16.2.2.3.	Объект, который находится на одну позицию ниже от самого верхнего
левого должен иметь координаты x = x0 и y = y0 + FIELD_SELL_SIZE.
16.2.2.4.	Аналогично должны рассчитываться координаты любого объекта на
поле.
16.2.3.	Создать новое хранилище объектов GameObjects и поместить в него все
объекты.
16.2.4.	Вернуть созданное хранилище.

Игра должна быть полностью рабочей. Проверь, если есть какие-то проблемы исправь их.

***************************************************************************************

Задание 15.

	Пришло время реализовать метод модели, отвечающий за движение move(), но для
начала реализуем вспомогательные методы. Добавь в класс модели методы:
15.1.	boolean checkWallCollision(CollisionObject gameObject, Direction direction). Этот 
метод проверяет столкновение со стеной. Он должен вернуть true, если при движении 
объекта gameObject в направлении direction произойдет столкновение со стеной, 
иначе false. Для определения столкновения используй метод isCollision() у игрового 
объекта.
15.2.	boolean checkBoxCollision(Direction direction). Этот метод проверяет 
столкновение с ящиками. Метод должен:
15.2.1.	Вернуть true, если игрок не может быть сдвинут в направлении direction (там 
находится: или ящик, за которым стена; или ящик за которым еще один ящик).
15.2.2.	Вернуть false, если игрок может быть сдвинут в направлении direction (там
находится: или свободная ячейка; или дом; или ящик, за которым свободная 
ячейка или дом). При это, если на пути есть ящик, который может быть сдвинут, то 
необходимо переместить этот ящик на новые координаты. Обрати внимание, что 
все объекты перемещаются на фиксированное значение FIELD_SELL_SIZE, не 
зависящее от размеров объекта, которые используются для его отрисовки.
Подсказка: для определения столкновений используй методы isCollision() игровых 
объектов и метод checkWallCollision() модели.
15.3.	void checkCompletion(). Этот метод должен проверить пройден ли уровень (на 
всех ли домах стоят ящики, их координаты должны совпадать). Если условие 
выполнено, то проинформировать слушателя событий, что текущий уровень завершен.
15.4.	void move(Direction direction). Метод должен:
15.4.1.	Проверить столкновение со стеной (метод checkWallCollision()), если есть 
столкновение – выйти из метода.
15.4.2.	Проверить столкновение с ящиками (метод checkBoxCollision()), если есть 
столкновение – выйти из метода.
15.4.3.	Передвинуть игрока в направлении direction.
15.4.4.	Проверить завершен ли уровень.

Запусти программу и проверь, что игрока можно перемещать, он может перемещать 
ящики, стены преграждают движение, а при перемещении всех ящиков в дома выводится 
сообщение о прохождении уровня.

***************************************************************************************

Задание 14.

	Добавим немного интерактивности в нашу игру (перемещение игрока с помощью
клавиатуры). Начнем с обработки нажатия клавиш клавиатуры.
14.1.	Добавь в класс Field вложенный класс KeyHandler унаследованный от 
KeyAdapter.
14.2.	Перегрузи у него метод keyPressed(). Если была нажата клавиша с кодом 
VK_LEFT, то пошли eventListener-у событие move с параметром Direction.LEFT. 
Аналогичным образом обработай нажатия клавиш с кодом VK_RIGHT, VK_UP и 
VK_DOWN. Если пользователь нажал клавишу R с кодом VK_R, то вызови у слушателя 
событий метод restart().
14.3.	В конструкторе класса Field:
14.3.1.	Создай объект класса KeyHandler.
14.3.2.	Установи его слушателем с помощью метода addKeyListener().
14.3.3.	Установи focusable в true (метод setFocusable()).

***************************************************************************************

Задание 13.

	Наполним контроллер функционалом.
13.1.	Добавь в конструктор класса Controller к тому, что уже есть еще и:
13.1.1.	Перезапуск модели.
13.1.2.	Установку слушателя событий у модели и представления. Слушателем должен 
быть сам контроллер.
13.2.	Реализуй методы контроллера:
13.2.1.	move(Direction direction) – должен вызывать move(Direction direction) у модели 
и update() у представления. Метода move() у модели еще нет, добавь для него 
заглушку, мы его реализуем позже.
13.2.2.	restart() – должен перезапускать модель и обновлять представление.
13.2.3.	startNextLevel() – должен запускать у модели новый уровень и обновлять 
представление.
13.3.	Добавь в представление метод completed(int level), который будет сообщать 
пользователю, что уровень level пройден. Метод должен:
13.3.1.	Обновлять представление.
13.3.2.	Показывать диалоговое окно с информацией о том, что пользователь прошел 
какой-то уровень. Подсказка: используй JOptionPane.showMessageDialog.
13.3.3.	Просить контроллер запустить следующий уровень.
13.4.	Реализуй в контроллере метод levelCompleted(int level), он должен вызвать 
метод completed() у представления.

***************************************************************************************

Задание 12.

	Попробуем организовать взаимодействие представления и модели.
12.1.	Добавь в класс View метод update(), он должен вызывать у игрового поля field 
метод repaint(). Другими словами, метод update() будет обновлять представление
(перерисовывать поле).
12.2.	Добавь в класс контроллера метод GameObjects getGameObjects(), он должен 
запросить игровые объекты у модели и вернуть их. Добавь такой же метод и в класс 
представления, он должен получать объекты у контроллера.
12.3.	Правильно реализуй в классе Field метод paint(Graphics g). Он должен:
12.3.1.	Залить все поле каким-то цветом, например, черным (вызови методы setColor и 
fillRect с правильными параметрами).
12.3.2.	Получить у представления все игровые объекты.
12.3.3.	Отрисовать все игровые объекты.

Запусти программу и проверь, что все игровые объекты рисуются правильно.

***************************************************************************************

Задание 11.

	Начнем наполнять функционалом класс модели Model. Добавь в него:
11.1.	Поле GameObjects gameObjects. Оно будет хранить наши игровые объекты.
11.2.	Поле отвечающее за текущий уровень int currentLevel. Проинициализируй его
значением 1.
11.3.	 Поле отвечающие за загрузчик уровней LevelLoader levelLoader.
Проинициализируй его с помощью файла levels.txt из папки res.
11.4.	Метод GameObjects getGameObjects(), он должен возвращать все игровые
объекты.
11.5.	Метод restartLevel(int level), он должен получать новые игровые объекты для
указанного уровня у загрузчика уровня levelLoader и сохранять их в поле gameObjects.
11.6.	Метод restart(), он должен перезапускать текущий уровнь, вызывая restartLevel
с нужным параметром.
11.7.	Метод startNextLevel(), он должен увеличивать значение переменной
currentLevel, хранящей номер текущего уровня и выполнять перезапуск нового уровня.

***************************************************************************************

Задание 10.

	В игре будет несколько уровней, все уровни будут храниться в текстовом файле. Сейчас мы
напишем тестовую реализацию загрузчика уровней LevelLoader. Почему тестовую? Полный 
функционал нам пока не нужен, он довольно сложный, оставим его на потом. А пока:
10.1.	Создай класс LevelLoader в пакете model.
10.2.	Добавь в класс конструктор, принимающий Path levels. Параметр levels – это 
путь к тестовому файлу, содержащему описание уровней.
10.3.	Добавь в класс LevelLoader метод GameObjects getLevel(int level). Пока не важно, 
что будет возвращать этот метод. Пусть он всегда возвращает набор из: одного игрока, 
одного дома, одного ящика и нескольких стен. Так будет проще отладить работу игры.
Координаты каждого объекта должны быть не нулевые и кратны половине 
FIELD_SELL_SIZE (центр каждого объекта должен быть в середине ячейки поля).

***************************************************************************************

Задание 9.

	В процессе работы игры, будут возникать различные события. Давай создадим интерфейс
слушателя событий EventListener. Его должен реализовывать каждый класс, который хочет 
обрабатывать события. А классы, которые будут генерировать события, будут вызывать 
методы этого интерфейса.
9.1.	Добавь интерфейс EventListener в пакет controller.
9.2.	Добавь в интерфейс методы:
9.2.1.	move(Direction direction) – передвинуть объект в определенном направлении.
9.2.2.	restart() – начать заново текущий уровень.
9.2.3.	startNextLevel() – начать следующий уровень.
9.2.4.	levelCompleted(int level) – уровень с номером level завершён.
9.3.	Добавь классу Controller интерфейс EventListener, напиши необходимые заглушки-
реализации интерфейса.
9.4.	Добавь в классы Model и Field по полю EventListener eventListener.
9.5.	Добавь в классы Model, View и Field по методу setEventListener(EventListener 
eventListener). Этот метод в классе View должен вызвать аналогичный метод у объекта 
field, а в классах Model и Field устанавливать значение внутренних полей eventListener.

***************************************************************************************

Задание 8.

	Ты создал полную коллекцию типов игровых объектов. Давай создадим класс, который
будет хранить эти объекты.
8.1.	Создай класс GameObjects в пакте model.
8.2.	Добавь в него:
8.2.1.	Поля Set<Wall> walls, Set<Box> boxes, Set<Home> homes и Player player.
8.2.2.	Геттеры для этих полей.
8.2.3.	Конструктор класса, принимающий Set<Wall> walls, Set<Box> boxes, Set<Home> 
homes, Player player и инициализирующий поля класса.
8.2.4.	Метод Set<GameObject> getAll(). Он должен возвращать множество, содержащее 
все объекты, хранящиеся внутри класса.

***************************************************************************************

Задание 7.

	Давай сделаем класс стены Wall. Стена может сталкиваться с другими объектами, но не
может двигаться.
7.1.	Добавь класс Wall в пакет model.
7.2.	Унаследуй класс от подходящего родителя.
7.3.	Добавь конструктор с параметрами int x и int y.
7.4.	Реализуй метод отрисовки.
Подсказка: стену можно нарисовать залитым квадратом коричневого цвета, но тебя
никто не ограничивает, прояви свою творческую суть по полной.

***************************************************************************************

Задание 6.

	Пришло время создать класс Home. Этот класс будет отвечать за места на игровом поле
(дома) в которые нужно сдвинуть все ящики. Объекты этого типа не должны передвигаться
по полю или сталкиваться с другими игровыми объектами.
6.1.	Добавь в пакет model класс Home.
6.2.	Класс должен быть унаследован от максимально подходящего базового класса.
6.3.	Добавь в созданный класс конструктор, принимающий int x и int y. Высота и ширина
дома должна быть равна 2.
6.4.	Реализуй метод отрисовки дома. Подсказка: можешь использовать красный цвет и
прозрачный круг.

Как и с предыдущими игровыми объектами, можешь проверить метод отрисовки в методе
paint() класса Field.

***************************************************************************************

Задание 5.

	Игровые объекты “Ящик” и “Игрок” с одной стороны являются объектами, которые могут
сталкиваться, а с другой они могут перемещаться по полю.
5.1.	Создай класс игрока Player и класс ящика Box в пакете model. Каждый из них
унаследуй от максимально подходящего класса.
5.2.	Созданные классы должны поддерживать интерфейс, отвечающий за движение
объектов.
5.3.	Добавь в созданные классы конструкторы, принимающие int x и int y.
5.4.	В каждом из классов, реализуй метод, отвечающий за движение. Он должен смещать
координаты объектов (x и y) на переданные значения.
5.5.	В каждом из них, реализуй метод, отвечающий за отрисовку. Этот метод должен:
устанавливать какой-то цвет и рисовать какие-то примитивные фигуры. Проследи,
чтобы центр фигуры имел координаты x и y, а высота и ширина соответствовали
значениям полей height и width.
Подсказка: игрока можешь нарисовать желтым залитым кругом, а ящик – оранжевым
квадратом с прорисованными диагоналями. Это пример, ты можешь сам выбрать цвет
и вид каждого объекта, ты ограничен только методами доступными для Graphics и
своей фантазией.

Для того чтобы проверить как рисуется твой ящик или игрок, ты можешь создать
объект типа Box или Player в методе paint() класса Field и вызвать у объекта метод
draw(). Сделай это исключительно для проверки методов draw(), в дальнейшем метод
paint() мы реализуем иначе.

***************************************************************************************

Задание 4.

	Общий класс игровых объектов GameObject уже есть. Пришло время создать классы
конкретных типов игровых объектов.
4.1.	Часть игровых объектов могут двигаться (игрок и ящики), а часть нет, например, стены
и дома.
4.1.1.	Добавь интерфейс Movable в пакет model.
4.1.2.	Интерфейс Movable должен иметь метод void move(int x, int y).
4.2.	Добавь enum Direction в пакет model. Он должен содержащий следующие значения:
LEFT, RIGHT, UP и DOWN. Этот тип будет использоваться для описания направления
движения объектов.
4.3.	Игровые объекты типа “дом” не поддерживают логики столкновений (игрок или
ящики могут свободно передвигаться по ним). Что касается остальных объектов, то
они не должны проходить свозь друг друга, они должны сталкиваться. Например,
ящик нельзя протолкнуть сквозь стену.
4.3.1.	Добавь абстрактный класс CollisionObject в пакет model.
4.3.2.	Класс CollisionObject должен быть унаследован от GameObject.
4.3.3.	Добавь в класс CollisionObject:
4.3.3.1.	Конструктор, принимающий int x и int y.
4.3.3.2.	Метод boolean isCollision(GameObject gameObject, Direction direction).
Этот метод должен возвращаться true, если при перемещении текущего
объекта в направлении direction на FIELD_SELL_SIZE произойдет
столкновение с объектом gameObject, переданным в качестве параметра.
Иначе – возвращать false. Столкновением считать совпадение координат x и y.

***************************************************************************************

Задание 3.

	Скоро мы займемся созданием различных игровых объектов. Было бы удобно иметь
возможность сразу их где-то нарисовать и посмотреть, как они выглядят. Объекты будут 
рисоваться на игровом поле Field.
Тебе пришел измененный код класса View, который создает объект поля Field и 
настраивает правильным образом представление View. А тебе нужно:
3.1.	Добавь в пакет view класс Field, унаследованный от JPanel.
3.2.	Добавь в класс Field:
3.2.1.	Конструктор с параметром View view.
3.2.2.	Поле View view, которое должно инициализироваться в конструкторе.
3.2.3.	Создай заглушку для метода paint(Graphics g), она пока ничего не будет делать.
3.3.	Добавь в конструктор класса контроллера вызов метода init() представления.
3.4.	Добавь в класс Controller метод main(), он должен создавать новый объект 
контроллера.

***************************************************************************************

Задание 2.

	Основа заложена, теперь перейдем к ее наполнению. Игровой процесс можно представить
как взаимодействие игровых объектов GameObject. У нас их будет несколько видов: ящик
Box, дом Home (место куда нужно поместить ящик), стена Wall и игрок Player.
2.1.	Добавь абстрактный класс GameObject в пакет model.
2.2.	Добавь в класс GameObject поля: int x, int y, int width и int height. Это будет позиция и
размер объекта для отрисовки.
2.3.	Добавь сеттеры и геттеры для полей класса.
2.4.	Добавь в класс Model публичную статическую константу int FIELD_SELL_SIZE = 20, это
будет размер ячейки игрового поле. Все игровые объекты будут занимать одну ячейку
игрового поля. Именно этот размер будет участвовать в расчёте движения и
столкновений объектов. Размер, который будет храниться внутри объекта, будет
использоваться только при его отрисовке.
2.5.	Добавь в класс GameObject два конструктора:
2.5.1.	GameObject(int x, int y)
2.5.2.	GameObject(int x, int y, int width, int height)
Конструкторы должны инициализировать все поля класса. Если width и height не переданы,
используй FIELD_SELL_SIZE в качестве ширины и высоты.
2.6.	Добавь абстрактный метод void draw(Graphics graphics) в класс GameObject. Этот метод
будет реализован в каждом типе игровых объектов по-своему. Другими словами,
каждый тип игровых объектов будет знать, как он должен рисоваться и будет сам себя
рисовать в графический контекст graphics. Graphics – это абстрактный класс из
библиотеки java.awt.

***************************************************************************************

Задание 1.

	Сегодня мы напишем свою реализацию игры Сокобан. Это логическая игра-головоломка,
более подробно про нее можешь прочитать в Википедии. Игра будет состоять из 3х 
основных компонентов (как ты догадался, тут не обошлось без паттерна MVC). 
Графический интерфейс будет реализован с использованием Swing.
1.1.	Создай пакет view и добавь в него класс View, унаследованный от JFrame. Этот класс 
будет отвечать за графическое представление нашей игры.
1.2.	Создай пакет model и добавь в него класс Model. Этот класс будет отвечать за модель 
нашей игры. Как тебе названия классов? Правда они непредсказуемые? :) На самом 
деле, очень важно назвать классы так, чтобы человек, который впервые видит твой 
проект, сразу понял за что они отвечают.
1.3.	Создай пакет controller и добавь в него класс Controller с конструктором по умолчанию.
1.4.	Добавь в класс View конструктор, который будет принимать Controller и сохранять его 
во внутреннем поле класса, которое тоже нужно добавить. Поле назови controller.
1.5.	Добавь в класс Controller поля View view и Model model. Проинициализируй их в 
конструкторе.
****************************************************************
Задание 9

Это последнее задание по MVC.

1. Следуя принципу MVC аналогично реализации предыдущих методов сделай следующее:
напиши логику обновления юзера. После обновления должен отображаться список юзеров.

Добавь ивент в EditUserView. Используй следующие сигнатуры публичных методов:
void fireEventUserChanged(String name, long id, int level)
void onUserChange(String name, long id, int level)
void changeUserData(String name, long id, int level)
где name и level - это новые значения для юзера с выбранным id

2. Добавь в main вызов fireEventUserChanged


****************************************************************
Задание 8

1. Следуя принципу MVC аналогично реализации предыдущих методов сделай следующее:
напиши логику удаления юзера. После удаления должен отображаться список юзеров.

Добавь ивент в EditUserView. Используй следующие сигнатуры публичных методов:
void fireEventUserDeleted(long id)
void onUserDelete(long id)
void deleteUserById(long id)

2. Добавь в main вызов fireEventUserDeleted

3. Отрефактори MainModel. Теперь, когда есть удаленные юзеры, часть методов стала работать неправильно.
Почти во всех методах, где требуется список пользователей, нужно работать только с активными(живыми) юзерами.
Вынеси в отдельный приватный метод получение списка всех юзеров и фильтрацию живых юзеров.
Отрефактори все методы, которые используют список юзеров. Они должны использовать список живых юзеров.


****************************************************************
Задание 7

1. Распредели методы по классам MVC:


public void onOpenUserEditForm(long userId) {
    ...loadUserById(userId);
    ...refresh(...getModelData());
}

public void fireEventOpenUserEditForm(long id) {
    ...onOpenUserEditForm(id);
}

public void loadUserById(long userId) {
    User user = userService.getUsersById(userId);
    ...setActiveUser(user);
}

!!!! Пользователь видит Вью со списком юзеров, нажимает на одного из них, запрос идет на сервер,
выгребаем новые данные и отображаем другую Вью, которая относится к одному выбранному пользователю.
Учти это при реализации этого задания.

2. Добавь в метод main открытие формы редактирования для пользователя с id=126


****************************************************************
Задание 6

Функционал отображения удаленных юзеров есть, а самих таких юзеров нет. Давай это исправим.
Давай сделаем новую Вью, которая будет отвечать за редактирование одного конкретного юзера.
UsersView отображает список пользователей.
EditUserView будет отображать даннные о редактировании конкретного юзера.
Для этого нам сначала нужен этот выбранный юзер.
Как и любые данные его поместим в ModelData.

1. Создай в ModelData поле User activeUser с геттером и сеттером (Alt+Insert -> Getter and Setter).

2. Аналогично UsersView создай EditUserView.
Логика метода refresh:
2.1. вывести в консоль "User to be edited:"
2.2. с новой строки вывести табуляцию и активного юзера
2.3. с новой строки вывести разделитель "==================================================="

3. Создай в контроллере поле EditUserView editUserView с сеттером.

Когда наши данные выводятся в консоль, то совсем не понятно, список каких юзеров - удаленных или нет - выводится.
Давай сделаем так, чтобы Вью отображала эту информацию. Все данные для отображения хранятся в Моделе. Поэтому:
4. создай в ModelData поле boolean displayDeletedUserList с геттером и сеттером.

5. Измени метод refresh в UsersView так, чтобы он отображал "All users:" либо "All deleted users:"
в зависимости от того, какие юзера находятся в списке. Добавь в необходимые методы модели изменение displayDeletedUserList.


****************************************************************
Задание 5

В сервисе есть метод, который возвращает всех удаленных пользователей. Давай их отобразим.

1. Распредели методы по классам MVC:

public void fireEventShowDeletedUsers() {
    ...onShowAllDeletedUsers();
}

public void onShowAllDeletedUsers() {
    ...loadDeletedUsers();
}

public void loadDeletedUsers() {
    List<User> users = userService.getAllDeletedUsers();
}

Не забудь, что данные, полученные с сервера, необходимо положить в ModelData. А потом обновить Вью.
Добавь это самостоятельно в нужные методы.

2. Добавь в Solution.main вызов нового метода, который ты поместил во Вью.

3. Добавь в интерфейс Model метод, который ты поместил в Модель, реализуй его в FakeModel: выброси UnsupportedOperationException


****************************************************************
Задание 4

Пора заменять нашу фейковую Модель на реальную, которая будет получать данные из DataSource.
В пакет model/service я добавил сервис для работы с юзерами.
Также в корне этой задачи ты найдешь утилитный класс Util.

1. Аналогично FakeModel создай модель MainModel.

2. Т.к. Модель обращается к сервисам, то в MainModel создай поле UserService userService, инициализируй объектом.

3. Реализуй логику метода loadUsers:
3.1. Достань всех пользователей между 1 и 100 уровнями
3.2. Положи всех пользователей в modelData

4. Обнови Solution.main: замени FakeModel на MainModel.
Преимущества MVC в том, что в любой момент времени легко можно заменить любую часть паттерна.


****************************************************************
Задание 3

Чтобы понимать, в правильном ли направлении ты движешся, тебе надо видеть данные. Поэтому
1. В пакете view создай класс UsersView, реализующий View. Он будет отображать список юзеров в консоль.

2. В UsersView создай поле-контроллер, также создай ему сеттер.

3. Реализуй логику метода refresh:
3.1. Выведи в консоль фразу "All users:".
3.2. Выведи в консоль всех юзеров, которые есть в modelData.
 Перед каждым юзером сделай отступ в виде табуляции.
3.3. В конце выведи визуальный разделитель данных
===================================================

4. Уже интересно посмотреть, что же получилось.
Добавь в UsersView публичный метод void fireEventShowAllUsers(), который сэмулирует событие клиента.
Обратись к контроллеру и вызови его нужный метод для отображения всех пользователей.

5. Класс Solution будет эмулятором пользователя. Открой класс Solution, стань на красный метод,
с помощью гарячих клавиш Идеи создай проперти(поле) для usersView.
Нужен только сеттер. Если у тебя создался геттер, то удали его.

6. Запусти main. Упс, ничего не вывело :(
Это получилось потому, что данные пришли с сервера, обновились в ModelData, но Вью ничего о них не знает.
Вью сама не умеет себя обновлять. Это делает Контроллер.
Пойди в контроллер и добавь обновление данных во Вью.
Напомню, данные хранятся в Моделе.

7. Запусти main. У меня теперь такой вывод:
All users:
	User{name='A', id=1, level=1}
	User{name='B', id=2, level=1}
===================================================
Ура, идем дальше.


****************************************************************
Задание 2

1. Создай пакет controller, в котором создай класс Controller.
Этот класс будет получать запрос от клиента, оповещать Модель об этом, а Модель, в свою очередь, будет обновлять ModelData-у.

2. Добавь в контроллер поле Model model вместе с сеттером.

3. В контроллере создай публичный метод void onShowAllUsers(), который должен обратиться к моделе и инициировать загрузку юзеров.

4. Создай пакет view. В нем создай интерфейс View.

5. В интерфейс View добавь два метода void refresh(ModelData modelData) и void setController(Controller controller)


****************************************************************
Задание 1

Привет! Эта задача будет на паттерн MVC - Model-View-Controller.
Мы вместе построим архитектуру используя MVC. Разберись подробно, что и почему нужно реализовывать так, как я тебе покажу.
Прочти дополнительную литературу, которую дает профессор в конце уровня.
Тебя, скорее всего, на собеседовании спросят об этом паттерне либо дадут задание, в котором нужно будет его реализовать.

Итак...
У тебя есть два пакета: bean, содержащий единственный класс User, и dao,
в котором хранится эмуляция базы данных в пакете mock и UserDao. UserDao - это уровень ДАО, т.е. уровень доступа к базе.
В нем размещают различные методы по сохранению и получению объектов из базы данных.
В реальном приложении строку private DataSource dataSource = DataSource.getInstance() не встретить.
Я реализовал DataSource в виде синглтона. В действительности, у тебя будет что-то такое:
@Autowired
private DataSource dataSource;
Фреймворк, которым ты будешь пользоваться, сам создаст объект базы данных и инициализирует поле dataSource.

Запомни, с ДАО уровнем работают сервисы. Никакие другие классы в ДАО не лезут. В сервисах описана бизнес логика.
Сервисы забирают данные из базы используя ДАО, обрабатывают их и отдают тому, кто данные запросил.
Однако не все данные хранятся в базе. Например, залогиненый пользователь будет храниться в специальном объекте - Моделе.
Объект, который содержит в себе данные, необходимые для отображения информации на клиенте, называется Моделью.
Также этот объект Модель содержит ссылки на все необходимые сервисы.
Если данных для отображения очень много, то их выделяют в отдельный объект.

Напишем приложение, которое будет показывать список юзеров и что-то делать с ними, например, обновлять их данные и удалять.

1. Создай пакет model, в котором создай класс ModelData.
ModelData - это объект, который будет хранить необходимые данные для отображения на клиенте.
Создай поле с геттером и сеттером List<User> users - это будет список юзеров для отображения.

2. Используя любую модель должна быть возможность получить все необходимые данные для отображения. Поэтому
в пакете model создай интерфейс Model, который должен содержать метод ModelData getModelData().

3. В пакете model создай класс FakeModel, реализующий Model. Он нам понадобится на начальном этапе.
В нем создай поле ModelData modelData, которое инициализируй объектом.

4. В интерфейсе Model создай метод void loadUsers().
Реализуй его в FakeModel: инициализируй список юзеров в modelData любыми данными. Они не влияют на тестирование.
У меня такие данные:
User{name='A', id=1, level=1}
User{name='B', id=2, level=1}
Думаю, ты помнишь, что все методы интерфейса являются public-ами, поэтому модификатор указывать не нужно.
Программисты часто мОкают данные на начальном этапе. Получение реальных данных реализовывается на последних этапах.
Мокать - это подменять реальные объекты на хардкоженные, тестовые данные.
